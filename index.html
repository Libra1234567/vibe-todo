<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Vibe To-Do ðŸŒŒ</title>

<!-- Externes Favicon -->
<link rel="icon" href="https://github.githubassets.com/favicons/favicon.png" type="image/png">

<!-- Bootstrap CSS -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet">

<style>
body.dark { background-color:#121212; color:#f1f1f1; }
body.dark .card { background-color:#1e1e1e; color:#f1f1f1; }
li.task-item { opacity:0; transform:translateY(-10px); transition:all 0.4s ease; }
li.task-item.show { opacity:1; transform:translateY(0); }
/* Dark Mode */
body.dark {
  background-color: #000000 !important;  /* kompletter Hintergrund schwarz */
  color: #f1f1f1 !important;
  transition: background-color 0.3s, color 0.3s;
}

/* Karte in Dark Mode */
body.dark .card {
  background-color: #1e1e1e !important;
  color: #f1f1f1 !important;
  border: 1px solid #333;
}

/* Inputfelder im Dark Mode */
body.dark input.form-control {
  background-color: #333;
  color: #f1f1f1;
  border: 1px solid #555;
}

/* Besser lesbare Hilfstexte in Dark Mode */
body.dark .text-muted.d-block {
  color: #b8c2cc !important;
}

/* Haupt-Task-Eingabe bewusst heller */
body.dark #taskInput {
  background-color: #444;
  border-color: #666;
}

body.dark #taskInput::placeholder {
  color: #d0d6dc !important;
  opacity: 1;
}

body.dark #reminderInput {
  color: #f5f7fa;
}

body.dark #reminderInput::-webkit-calendar-picker-indicator {
  filter: invert(1) brightness(1.3);
}

body.dark .task-date {
  color: #c9d4e0 !important;
}

/* Drag & Drop */
.drag-handle {
  cursor: grab;
  touch-action: none;
  user-select: none;
  margin-right: 0.75rem;
}

.drag-handle:active {
  cursor: grabbing;
}

.drag-ghost {
  opacity: 0.5;
}

/* Buttons im Dark Mode */
body.dark .btn-primary {
  background-color: #6c63ff;
  border-color: #6c63ff;
  color: #fff;
}

body.dark .btn-outline-secondary {
  color: #f1f1f1;
  border-color: #6c63ff;
}

/* Listenitems */
body.dark .list-group-item {
  background-color: #222 !important;
  color: #f1f1f1 !important;
  border: 1px solid #333;
}

/* Animation */
li.task-item { 
  opacity: 0; 
  transform: translateY(-10px); 
  transition: all 0.4s ease; 
}

li.task-item.show { 
  opacity: 1; 
  transform: translateY(0); 
}

/* Emoji-kompatible Font */
body {
  font-family: "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", "Twemoji", system-ui, sans-serif;
}


</style>
</head>
<body class="bg-light">

<div class="container py-5">
  <div class="card p-4 shadow">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h3 class="mb-0">ðŸŒ€ Vibe To-Do</h3>
      <button id="darkToggle" class="btn btn-outline-secondary btn-sm">ðŸŒ—</button>
    </div>

    <div class="input-group mb-3">
      <input id="taskInput" type="text" class="form-control" placeholder="Was willst du erledigen">
      <input id="reminderInput" type="date" class="form-control">
      <button id="voiceBtn" class="btn btn-outline-secondary" type="button" aria-label="Spracheingabe starten" aria-pressed="false">ðŸŽ¤</button>
      <button class="btn btn-primary" onclick="addTask()">+</button>
    </div>
    <small id="voiceHint" class="text-muted d-block mb-3"></small>

    <ul id="taskList" class="list-group"></ul>
  </div>
</div>

<!-- Bootstrap JS Bundle -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"></script>
<!-- SortableJS for Drag & Drop (inkl. Touch Support) -->
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>

<script>
const list = document.getElementById("taskList")
const taskInput = document.getElementById("taskInput")
const reminderInput = document.getElementById("reminderInput")
const darkToggle = document.getElementById("darkToggle")
const voiceBtn = document.getElementById("voiceBtn")
const voiceHint = document.getElementById("voiceHint")
const tasksById = new Map()

const sortable = new Sortable(list, {
  animation: 150,
  handle: ".drag-handle",
  ghostClass: "drag-ghost",
  fallbackOnBody: true,
  swapThreshold: 0.65,
  onEnd: () => {
    persistTaskOrder()
  }
})

const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition
const recognition = SpeechRecognition ? new SpeechRecognition() : null
let isListening = false

if (recognition) {
  recognition.lang = "de-DE"
  recognition.interimResults = true
  recognition.maxAlternatives = 1

  voiceHint.textContent = "Tipp: Klicke auf ðŸŽ¤ und sprich deinen Task ein."

  recognition.onstart = () => {
    voiceBtn.classList.add("active")
    voiceBtn.setAttribute("aria-pressed", "true")
    voiceHint.textContent = "ðŸŽ¤ HÃ¶re zu..."
  }

  recognition.onresult = (event) => {
    let transcript = ""

    for (let i = event.resultIndex; i < event.results.length; i += 1) {
      transcript += event.results[i][0].transcript
    }

    const normalizedTranscript = transcript.trim()
    if (!normalizedTranscript) return

    taskInput.value = normalizedTranscript
    voiceHint.textContent = "âœ… Text erkannt. Du kannst den Task jetzt speichern."
  }

  recognition.onerror = () => {
    voiceHint.textContent = "Spracherkennung fehlgeschlagen. Bitte erneut versuchen."
  }

  recognition.onend = () => {
    isListening = false
    voiceBtn.disabled = false
    voiceBtn.classList.remove("active")
    voiceBtn.setAttribute("aria-pressed", "false")
  }

  voiceBtn.addEventListener("click", () => {
    if (isListening) {
      recognition.stop()
      voiceHint.textContent = "ðŸ›‘ Aufnahme gestoppt."
      return
    }

    isListening = true
    voiceBtn.disabled = true
    voiceHint.textContent = "ðŸŽ¤ Mikrofon wird gestartet..."

    try {
      recognition.start()
    } catch {
      isListening = false
      voiceBtn.disabled = false
      voiceHint.textContent = "Spracherkennung ist bereits aktiv. Bitte kurz warten."
    }
  })
} else {
  voiceBtn.disabled = true
  voiceHint.textContent = window.isSecureContext
    ? "Spracherkennung wird in diesem Browser nicht unterstÃ¼tzt."
    : "Spracherkennung ist nur verfÃ¼gbar, wenn die Seite unter HTTPS oder auf localhost lÃ¤uft."
}

// Notifications (guarded for unsupported browsers and insecure contexts)
const supportsNotifications = "Notification" in window
const isSecureContext = window.isSecureContext
const canRequestNotifications = supportsNotifications && isSecureContext
if (!isSecureContext) {
  console.warn("Notifications require HTTPS or localhost to request permission.")
}
if (canRequestNotifications && Notification.permission !== "granted") {
  Notification.requestPermission()
}

// Dark Mode Toggle
darkToggle.addEventListener("click", () => {
  document.body.classList.toggle("dark")
})

// Enter fÃ¼gt Aufgabe direkt hinzu
taskInput.addEventListener("keydown", (event) => {
  if (event.key !== "Enter") return
  event.preventDefault()
  addTask()
})

// Pfad zur PHP-API
const API = "api/tasks.php"

// Lade Tasks von PHP-FileDB
async function loadTasks() {
  try {
    const res = await fetch(API)
    const tasks = await res.json()
    let needsPersist = false
    tasks.forEach(task => {
      const normalized = normalizeTask(task)
      if (!task.id) needsPersist = true
      renderTask(normalized)
      scheduleReminder(normalized)
    })
    if (needsPersist) {
      await persistTaskOrder()
    }
  } catch(e) {
    console.error("Fehler beim Laden der Tasks:", e)
  }
}

// Aufgabe hinzufÃ¼gen
async function addTask() {
  const text = taskInput.value.trim()
  const reminder = reminderInput.value
  if (!text) return
  const task = { id: createTaskId(), text, reminder, done: false }

  // POST Add
  await fetch(API, {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify(task)
  })

  renderTask(task)
  scheduleReminder(task)
  taskInput.value = ""
  reminderInput.value = ""
}

// Aufgabe rendern mit Animation
function renderTask(task) {
  const li = document.createElement("li")
  li.className = "list-group-item task-item d-flex justify-content-between align-items-center"
  li.dataset.taskId = task.id
  li.innerHTML = `
    <div class="d-flex align-items-center">
      <span class="drag-handle" aria-label="Aufgabe verschieben" role="button">â ¿</span>
      <div>
      <strong>${task.text}</strong>
      ${task.reminder ? `<small class="text-muted d-block task-date">ðŸ“… ${new Date(task.reminder).toLocaleDateString()}</small>` : ""}
      </div>
    </div>
    <button class="btn btn-danger btn-sm" onclick="removeTask(this,'${task.text}')">âœ–</button>
  `
  list.appendChild(li)
  tasksById.set(task.id, task)
  requestAnimationFrame(() => li.classList.add("show"))
}

// Aufgabe lÃ¶schen (POST-Simulation fÃ¼r Shared Hosting)
async function removeTask(btn,text) {
  const listItem = btn.closest("li")
  const taskId = listItem?.dataset.taskId
  await fetch(API, {
    method: "POST",
    headers: {"Content-Type":"application/x-www-form-urlencoded"},
    body: "action=delete&text=" + encodeURIComponent(text) + "&id=" + encodeURIComponent(taskId || "")
  })
  if (taskId) {
    tasksById.delete(taskId)
  }
  listItem?.remove()
}

// Reminder
function scheduleReminder(task) {
  if (!canRequestNotifications) return
  if (Notification.permission !== "granted") return
  if (!task.reminder) return
  const delay = new Date(task.reminder) - new Date()
  if (delay <= 0) return
  setTimeout(() => new Notification("ðŸ“ Erinnerung",{body:task.text}), delay)
}

// Initial load
loadTasks()

function createTaskId() {
  if (window.crypto?.randomUUID) {
    return window.crypto.randomUUID()
  }
  return `task-${Date.now()}-${Math.random().toString(16).slice(2)}`
}

function normalizeTask(task) {
  return {
    id: task.id || createTaskId(),
    text: task.text || "",
    reminder: task.reminder || "",
    done: Boolean(task.done)
  }
}

async function persistTaskOrder() {
  const orderedTasks = Array.from(list.children)
    .map((item) => tasksById.get(item.dataset.taskId))
    .filter(Boolean)

  if (!orderedTasks.length) return

  await fetch(API, {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ action: "reorder", tasks: orderedTasks })
  })
}
</script>
</body>
</html>
